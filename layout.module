<?php

/**
 * @file
 * Responsive layout builder tool for Panels.
 */

/**
 * Implements hook_menu().
 */
function layout_menu() {
  $items = array();

  // Regions.
  $items['admin/structure/panels/layouts/regions'] = array(
    'title' => 'Responsive regions',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'layout_admin_region_list',
    'access arguments' => array('administer layouts'),
    'weight' => 0,
    'file' => 'layout.admin.regions.inc',
  );
  $items['admin/structure/panels/layouts/regions/add'] = array(
    'title' => 'Add region',
    'page callback' => 'layout_admin_region_edit',
    'access arguments' => array('administer layouts'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'layout.admin.regions.inc',
  );
  $items['admin/structure/panels/layouts/regions/%layout_region/edit'] = array(
    'title' => 'Edit region',
    'page callback' => 'layout_admin_region_edit',
    'page arguments' => array(5),
    'access arguments' => array('administer layouts'),
    'type' => MENU_CALLBACK,
    'file' => 'layout.admin.regions.inc',
  );
  $items['admin/structure/panels/layouts/regions/%layout_region/delete'] = array(
    'title' => 'Delete region',
    'page callback' => 'layout_admin_region_delete',
    'page arguments' => array(5),
    'access arguments' => array('administer layouts'),
    'type' => MENU_CALLBACK,
    'file' => 'layout.admin.regions.inc',
  );

  // Grids.
  $items['admin/structure/panels/layouts/grids'] = array(
    'title' => 'Responsive grids',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'layout_admin_grids',
    'access arguments' => array('administer layouts'),
    'weight' => 10,
    'file' => 'layout.admin.grids.inc',
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function layout_permission() {
  return array(
    'administer layouts' => array(
      'title' => t('Administer responsive layouts'),
      'description' => t('Administer backend settings for responsive layouts.'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function layout_theme() {
  return array(
    'layout_admin_region_list_form' => array(
      'render element' => 'form',
      'file' => 'layout.admin.regions.inc',
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function layout_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'panels' && $plugin_type == 'layouts') {
    return "plugins/$plugin_type";
  }
}

/**
 * Add or update region in common set of regions.
 *
 * @param $region
 *   Region object with keys 'machine_name' and 'label'.
 */
function layout_region_save($region) {
  $new_values = array(
    'label' => $region->label,
  );

  // Only add the custom and weight keys if passed in. When updating existing
  // items, they might not be provided, so we should not set them to overwrite
  // existing values.
  if (isset($region->custom)) {
    $new_values['custom'] = $region->custom;
  }
  if (isset($region->weight)) {
    $new_values['weight'] = $region->weight;
  }

  // Add or update the region with the given machine name.
  return db_merge('layout_regions')
    ->key(array('machine_name' => $region->machine_name))
    ->fields($new_values)
    ->execute();
}

/**
 * Load all common layout regions.
 */
function layout_region_load_all() {
  // Get non-custom regions first in order of weights. Weight is not relevant
  // for custom regions because we don't include them in the default layout.
  return db_select('layout_regions', 'lr')
    ->fields('lr')
    ->orderBy('custom')
    ->orderBy('weight')
    ->execute()
    ->fetchAll();
}

/**
 * Load one layout based on its machine name.
 */
function layout_region_load($machine_name) {
  return db_select('layout_regions', 'lr')
    ->fields('lr')
    ->condition('machine_name', $machine_name)
    ->execute()
    ->fetchObject();
}

/**
 * Delete one layout based on its machine name.
 */
function layout_region_delete($machine_name) {
  return db_delete('layout_regions')
    ->condition('machine_name', $machine_name)
    ->execute();
}

/**
 * Get all responsive layout info arrays from panels.
 */
function layout_get_responsive_layouts() {
  ctools_include('plugins', 'panels');
  $all_layouts = panels_get_layouts();
  $responsive_layouts = array();
  foreach ($all_layouts as $name => $data) {
    if (empty($data['builder']) && isset($data['layout']->plugin) && ($data['layout']->plugin == 'responsive')) {
      $responsive_layouts[$name] = $data;
    }
  }
  return $responsive_layouts;
}

/**
 * Get a list of layout names using the given region machine name.
 */
function layout_get_layouts_using_region($machine_name) {
  $layouts = layout_get_responsive_layouts();
  $layouts_using_region = array();
  foreach ($layouts as $name => $data) {
    if (isset($data['layout']->settings['regions']) && is_array($data['layout']->settings['regions']) && isset($data['layout']->settings['regions'][$machine_name])) {
      $layouts_using_region[$data['layout']->name] = $data['title'];
    }
  }
  return $layouts_using_region;
}

/**
 * API function to get all responsive grids on the site.
 */
function layout_get_grids() {
  return variable_get('layout_grids', array());
}

/**
 * API function to set all responsive grids on the site.
 */
function layout_set_grids($grids) {
  return variable_set('layout_grids', $grids);
}

/**
 * Look up one grid setup based on machine name.
 */
function layout_grid_load($machine_name) {
  $grids = layout_get_grids();
  if (isset($grids[$machine_name])) {
    return $grids[$machine_name];
  }
}

/**
 * Build CSS for the grids with media queries.
 *
 * @todo
 *   Figure out a good way to avoid equal max/min-weights in subsequent
 *   grids if that is a problem.
 */
function layout_get_grid_css() {
  $grids = layout_get_grids();

  $grid_css = array();
  $min_width = 0;

  foreach ($grids as $index => $grid) {
    $first_grid = empty($min_width);
    $last_grid = ($index == count($grids) -1);

    // Build the media query for this grid. The first item should not have a
    // min-width (open ended to 0), and the last item should have no max-width
    // (open-ended to infinity). Mid-items should both have a min-width and a
    // max-width.
    $grid_css[] =
      '@media screen and (' .
      ($first_grid ? '' : 'min-width:' . $min_width) .
      ((!$first_grid && !$last_grid) ? ') and (' : '') .
      ($last_grid ? '' : 'max-width:' . $grid->width) .
      ') {';
    $grid_css[] = $grid->css;
    $grid_css[] = '}';

    // Remember min-width for next grid if applicable. The grids are in
    // ascending width order, so we can rely on this sequence.
    $min_width = $grid->width;
  }

  return join("\n", $grid_css);
}
